---
title: "shiny_vs_dash"
output: html_document
date: "2024-07-14"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Дисклеймер

В данной статье не будут расмотрены многие решения для дашбордина: [Tableau](https://www.tableau.com/), [Power BI](https://www.microsoft.com/en-us/power-platform/products/power-bi), [Streamlit](https://streamlit.io/), [Shiny For Python](https://shiny.posit.co/py/), [Dash For R](https://github.com/plotly/dashR) и другие. 

![](https://habrastorage.org/webt/oh/gf/cf/ohgfcfvn64cbryzzx1owaaqvpeq.png)

Часть статьи будет отрожать мой персональный опыт, а значит должна восприниматься с осторожностью.

## Введение

Статьи, прочитанные мной про оба фрейморка, сводили все к boiler plate коду или спорили о вкусах. Предлагаю обсудить вещи чуть более важные 

* Архитектура
* Клиент-серверное взаимодействие
* Дерево каталогов
* Краткое описание движка
* Маштабируемость и деплой
* Тестирование


## Архитектура

### Shiny
Shiny представляает из себя statefull single page application (SPA). Statefull означает что сервер будет хранить состояние пользовательской сессии для каждокого пользователя: данные о пользователе и сессии, данные о всех его inputs/outputs различные настройки и приложение может использовать эту информацию при обработке следующих взамодействий, оптимизируя их выполнеие. SPA(single page apptilcation) подразумевает что все взаимодействие пользователя с приложением происходит в рамкам единственной веб-страницы, без каких либо перезагрузок, раутинга и.п. Это обеспечивает дальнейшем пользователь получит плавное и непрерывное взаимодействие с ней. Все это звучит очень хорошо, особенно для дашбординга, где достаточно много интерактивных элементов.  Однако состояния пользовательских сессий нужно хранить, а каждая сессия это отдельный изолированный процесс. Но пока у вас небольшое приложение, расчитанное на ограниченное количество пользователей, это не будет проблемой. Конечно, когда оно разрастется, а это частая история - то и прогружаться оно будет тяжелее и выстроить по нему навигацию в рамках одной страницы будет сложно. 

### Dash
Dash представляет из cебя слегка иную  концепцию - stateless SPA с поддержкой url. Stateless означачет что сервер не сохраняет состояние специфичное для каждого пользователя. Каждый запрос от клиента к серверу обрабаывается отдельно и независимо от предыдущих запросов. При этом каждый запрос самодостаточный и содержит все необходимую информацию для его обработки сервером. Dash позволяет строить MPA с помощью `dcc.Link` и `dcc.Loacation`, но рендерится они будут как SPA, без полной перезагрузки приложения. Каждая из этих страниц регистрируется через `dash.registar_page`, позволящий задать путь для роутинга, сама страница будет отображаться в `app.page_container`. 


## Клиент-серверное взаимодействие

### Shiny
Что же обеспечивает архитектурную концепцую Shiny Web App ? В качестве основных сетевых протоколов используется HTTPS и WebSocket. HTTPS необходим для загрузки той единственной веб-страницы в браузер пользователя. Как только прогрузка завершается между клиентом и пользователем образуется соединение, использующие WebSocket протокол. WebSocket представляет из себя дуплексный канал через длительное TCP соединение, позволяя передовать данные в обоих направлениях без значительных дополнительных издержек. Тем самым мы и обеспечиваем плавность взаимодействия клиентов с Shiny приложением и сессию как таковую. За создание этого добра отвечает пакет [httpuv](https://cran.r-project.org/web/packages/httpuv/index.html), утилизирующий libuv и http-parser из С. Несмотря на отличные качества для дашбородинга, это решение не лишено своих проблем: как управлять жизненным циклом сессии, как маштабироваться при таком подходе и т.п.

### Dash

В отличие от Shiny, дефолтный Dash использует стандартный http/https, для общения между клиентом и сервером. Когда пользователь заходит на ваше приложение, он отправляет инициализирующий запрос, запрашивающий контент слиинкованным с url. По этому запросу сервер отправляет клиенту сгенерированный на основе нашего python кода HTML, CSS, JS.   Dash для своей  работы использует Flask сервер, который можно заменить Flask любым Flask like решением, совместимым с Dash. Скажем [Quart](https://github.com/pallets/quart). И здесь мы уже можем задать endpoint, утилизирующий websocket протокол или ассинхронность. Подробнее об этом можно почитать [тут](https://www.dash-extensions.com/components/websocket)


## Структурная архитектура кода и дерево каталогов

### Shiny
Типичная файловая структура Shiny проекта представляла из себя точку входа app.R, директорию `www` содержащую .js скрипты, .css, картинки и датасеты, директорию `tests` и виртуальное окружение renv. А также разные файлы конфигурирующие СI/CD. Пока все неплохо, но до 2016 года Shiny не поддерживал модульность, а ожидал от вас одну UI функцию и одну сервер функцию. Поэтому все сшивалось  в единое полотно, через либо приходилось возиться с `source`. Чтобы хоть как-то облегчить себе жизнь, код способный работать вне реактивного контекста выносили в отдельный пакет. Работать с этим  крайне неудобно, особенно если проект разрастался.  Огромное количество легаси остается написанным в таком стиле, а многие приложения продолжают писаться в одном файле.  Примерно в 2016  году Posit понял, что так жить нельзя, а где-то к 2019 и выкатил [shiny modules](https://mastering-shiny.org/scaling-modules.html).  Каждый модуль предстаялет из себя UI и server компонент, связанные через id. Модули можно и нужно переиспользовать, они в идеале должны содержать оптимальную порцию бизнес логики и если начать работать с ними, а рядовому R пользователю на них реально сложно переключится, так как в нативном R модулей нет в принципе, то процесс разработки имеет шансы не выдать по итогу спагетти код. Современная shiny разработка доовльно часто ведется с помощью фрэймворка [golem](https://engineering-shiny.org/golem.html). Golem предсоздает полезные скрипты для деплоя, конфигурации приложения,  позволяет удобно добавлять модули, тесты, документацию. Советую новые проекты начинать на нем.

### Dash

Тут дела обстоят гораздо проще. Dash приложение мало чем отличается от любого пакета в python

![](https://habrastorage.org/webt/ry/dl/ut/rydlutiays6b6un2i4xwekjujmy.png)

Так что мы можем организовывать наш код так как мы примыкли это делать. Конечно от нас будут ожидать предоставление точки входа и определеноой файловой структуры. Как я уже говорил, Dash позволяет создавать MPA с помощью `dash.registar_page`. По дефолту Dash будет искать эти страницы в директории `pages`.

```
- app.py
- pages
   |-- analytics.py
   |-- home.py
   |-- archive.py
```

В директории `assets` приложение ожидает увидеть .css, .js файлы, а также картинки, видео и т.п. Файлы для бэкенда, описывающие логику и layout страниц можно расположить в различных мождулях, что позволяет удобно разделить и переспоильзовать логику между компонентами приложения. 

## Краткое описание движка

### Shiny

В Shiny выделяют 3 группы объектов или ролей реактивного программирования: reactive source, reactive conductor, reactive endpoint. Reactive source - все что регистрируется как input аргумент server функции. Reactive conductor - представляется из себя expression, способный работать с реактивным контекстом и выдавать результат в ответ на изменения reactive source. Reactive endpoint - все что зарегестрировано как output нашего приложения. Обновления output создает side effect в виде обновления UI. Как только запускается новая сессия, Shiny не знает ничего о взаимосвязи конретного input виджета с каким либо reactive conductor/reactive output. Reactive output и reactive expression  инвалидированы. Shiny выбирает рандомный reactive output и если он зависит от какой-то реактивной переменнной, которая может прийти из reactive source (input) или reactive conductor(reactive expression), то устанавливает между ними связь. Реактивная переменная поступающая их reactive source передается мгновенно.  Резульат reactive expression вычисляется единожды, а так как они могут быть связаны с несколькими reactive output, то он по сути кэшируется для нях. Как только все outputs вычислены, наше приложение готово к работе. Пользователь начинает работать с приложением изменяя reactive source, который подписан на DOM event (change, input, click), через метод subscribe. Данный метод запускает callback, чья задача уведомить shiny server об изменении состояния элемента, а также передать это новое состояние. Упрощенно это можно представить так

```
el.addEventListener('input', function() {
  // This function is the callback that Shiny uses
  Shiny.onInputChange('input_id', el.value);
});

```

Как только shiny server получает новое значение, он инвалидирует все взаимосяви с reactive expression/sourсe. И мы приходим по сути к изначальному состоянию, когда нам нужно вновь вычислить все инвалидированные reactive outputs.

### Dash

В ходе иннициализации `Dash`, получает приложение пробегается через имоптированные модели, запускает их, и  с помощью `inspect.getmbembers` ищет все объекты, продекарированные `@callback`. `@callback` принимает в себя один или несколько `Output`, `Input`, `State`  `Output` отвечает за конкретный компонент, к которому мы обращаемся по id и обновляем  его аттрибуты. `Input` компоненты, изменение в котором должны стриггерить callback функцию. `State` - компоненты, чьи аттрибуты нам важны при исполнении callback функции, но они не триггерят его. Каждый `@callback` добавляет информацию о себе в глобальную переменную `GLOBAL_CALLBACK_MAP`, предтавлющую из себя словарь. Ключом к этому словарю будет `id` составленный на основе `Output`, а значением будет объект функции. Чтобы не возникли коллизии, мы должны добавлять `allow_duplicate=True`, если несколько callback функций обновляют один аттрибут объекта. Затем происходит конфигурация сервера, при которой `GLOBAL_CALLBACK_MAP` копируется в app.callback_map. Каждый flask.request к приложению проходит через метод `dispatch`, из его body получают информацию о Output, Input, State, background callback manager и т.п. На основе этих данных происходит поиск в app.callbakc_map, выставляется конекст и в `ctx.run` запускается функция. На основе полученного ответа формируется flask.Response, который отправялется клиенту. Как я упоминал, мы можем предоставить специальный callback manager. Если ваш `@callback` требует много времени для исполнения, то лучше использовать `@long_callback`: мы можем поместить его в отдельную очередеь (background callback queue), управляюмую callback manager и не оказаться в ситуации, при которой приложение заблокировано выполнением длительных операций, а также добавить возмможность кэширования результатов. Также можно задать дефолтное значение во время исполнения, добавить progress bar или условаия при которых исполнение callback функции прикратится


## Маштабируемость и деплой

## Shiny
Пойдем мы с вами от бесплатных решений к платным, все таки нельзя недооценивать силу халявы. Если у вас мало времени и денег, лучшим выбором станет PaaS [https://www.shinyapps.io/](https://shiny.posit.co/r/articles/share/shinyapps/). Бесплатный тир позволяет задеплоиться максимально быстро и просто и на этом все. А чего еще можно ожидать от пробника PaaS ? За ним следует [shiny server](https://posit.co/products/open-source/shinyserver/). Тут у вас максимум свободы, но и ответвенности. Shiny server можно поставить на множество линукс дистрибутивов. Или можно воспользоваться [docker image](https://hub.docker.com/r/rocker/shiny). Так как коммерческая версия (Shiny Server Pro) отжила свое, то никакой поддержки или жирного функционала идущего из коробки ждать не приходится, а приходится конфигрурировать все самому. А конфигурировать там есть что, скажем из за того что Shiny это statefull приложение, то ему нужен load balancer со sticky session. Доставать метрики и логи тоже будет не так просто.  Ну и наконцец [Posit Connect](https://posit.co/products/enterprise/connect/). На самом деле незаменимая вещь, если количество дашбордов и активных авторов переваливает за 100. Позволяет деплоится в 1 кнопку, поддерживает множество типов аутентификаций,  сам автор приложения может легко настроить доступ к нему, балансировку, сбор логов и метрик. А самое приятное, пригоден не только для деплоя shiny, но и Dash, Steamlit, Flask, маркдаунов и много чего еще. Из минусов - за него придется платить, и по отзывам служба поддержки posit становится хуже год от года. 


## Заключение

В тех статьях что читал я, принято было как в телевикторинах, за каждый раунд сравнения начислять очки а потом говорить, они шли ноздря в ноздрю, но вот boiler plate code у Dash меньше, он выигрывает с не большим отрывом и наоборот. Я здесь этого делать не буду, а всего лишь выдам простую истину: если вы знаете R - пишите на Shiny, если вы знаете Python - пишите на Dash. Или как говорил ведущий одной известной телевикторины: ваше очко уйдет в зрительный зал. Просто сделать свич у вас не получится, а скорее всего получится клубок из коллбеков и кода. Если же вы не пишите код, а заставляете писать других, ну или знаете и то и то и вы быстро пролистали до конца статьи: если ваш дашборд планирует расширятся в сторону взаимодействия с внешними сервисами - облака, HPC и т.п. лучше выбрать Python и Dash. У R тут могут быть ощутимые риски в виде написания своего велосипеда. Если ваше приложение планираует погружение в глубокую, наукоемкую доменную область - то велика вероятность того, что нужные вам решения уже любезно написаны R комьюнити ученых. И вам не предется вбивать статью с хитрой математической поправкой в chatgptв надежде что она сгенерит вам что-то рабочее. Если вам повезло расти в обоих направлениях, то возможно стоит проложить мост между R и Python. Но об этом в другой статье. 